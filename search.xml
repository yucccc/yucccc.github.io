<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次uc面试]]></title>
    <url>%2F2017%2F09%2F07%2F%E8%AE%B0%E4%B8%80%E6%AC%A1uc%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[很有幸的去uc面试，面试过程问的顺序是从笔试到你简历上写的技术，最后到之前待过的公司，下面记录一下遇到的问题 笔试1.写一个中间自适应，左右固定100px的三栏布局，这个问题基本都没问题，网上也很多答案。 参考 CSS三栏布局5种解决方案 问: 网格布局有什么问题，有没在实际中应用，flex有哪些兼容性问题，兼容性写法有哪些 2.根据下面布局填写所缺的css样式 3.请阅读以下代码，并把运行结果写到下方注释中123456 const foo = ((x, f = (y = x) =&gt; x + y) =&gt; &#123; let y = f(); x = y++; return [x, y, f(y)] &#125;)(2)// foo = 4.如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标？ 5.根据上面生成的数组，乱序排列 6.不使用loop，根据乱序排序后生成的数组，将前十个数相加. 7.如果前端代码部署，主页面放在自己服务器，静态资源部署到cdn 应该怎么部署，怎么保证同步 参考: 大公司里怎样开发和部署前端代码？ 技能1.你用过nodejs的那些模块，当项目部署时你如何保证node热更新 2.怎么知道那个dom发生了变化，如何对比，有没可能存在跨节点对比，diff如何解决这个问题 3.webpack如何构建多页面，多页面命名有什么规范 4.有没读过jQuery与zepto的源码，两者有什么区别，和vue又有什么区别 5.Mv*思想，如何实现一个mvvm框架 公司1.之前公司多少人，多人如何协作 最后1.你平时如何提升自己，如何快速成长（他说他两年达到了p6p7的级别，我当时仰慕的啊~~~）]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出JavaScript原型]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJavaScript%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[图文并茂的帮助你更好的理解JavaScript原型.熟记并理解以下规则,保你深入理解对象原型,保你面试无忧.1 . 任何对象都拥有__proto__(隐式原型) 属性, 一般指向他们的构造函数的原型 (prototype). 1234var a = new Array ()// a 是一个数组对象 默认拥有__proto__ 属性console.log(a.__proto__ === Array.prototype); // true白话就是 由谁创建 其__proto__ 就指向谁的 prototype 2 . 原型链的顶端是Object.prototype，其 __proto__为 null 12console.log(Object.prototype.__proto__ === null); // true// 这是一个特例,为了避免JavaScript死循环. 3 . 所有函数都拥有prototype （显式原型）属性 1任何函数的 prototype.__proto__ 都指向 Object.prototype 特例见第 2 4 . 所有函数都是Function 的 实例 123456function fn () &#123; // some code&#125;// fn 是 Function 构造函数创建出来的// 因此 fn 的 __proto__ 属性指向 Function 的 原型对象console.log(fn.__proto__ === Function.prototype); // true 类似的 十分容易就能理解 12345var obj = &#123;&#125; // 可以看做是 var obj = new Object ()var arr = [] // var obj = new Array ()// 因此他们的构造函数分别是 Object 和 Arrayconsole.log(obj.__proto__ === Object.prototype); // trueconsole.log(arr.__proto__ === Array.prototype); // true 5 . 更奇葩的来了，Object Function Array 本身也都是一个函数，由于是最常用的，所以JavaScript帮我们实现了 123456// 当我们通过构造函数的方式来创建一个对象 ，其本质也是new一个普通的函数// 因此可以得出console.log(Function.__proto__ === Function.prototype); // trueconsole.log(Object.__proto__ === Function.prototype ); // trueconsole.log(Array.__proto__ === Function.prototype); // true// 可印证 第4点 6 . 原型对象中又拥有constructor属性,该属性指向函数本身,这个好理解 123console.log(Function.prototype.constructor === Function); // trueconsole.log(Object.prototype.constructor === Object); // trueconsole.log(Array.prototype.constructor === Array); // true 7 . 先普及一波 原型链 概念 如果想要找到一个对象的属性,首先会先在自身查找,如果没有,就会通过__proto__属性一层层的向上查找,直到原型链的顶端 Object.prototype(__proto__: null）见第2这种通过某种纽带(__proto__)将对象之间形成一种继承关系 这种关系呈现出一种链条的形状 将这种链条称之为原型链 8 . 根据第 6 条可以推论得: 1234567console.log(fn.constructor===Function); // true// 解析:// fn自身并没有constructor属性,所以他会顺着原型链向上找// fn.__proto__ 指向的是 Function.prototype 见第4// Function.prototype.constructor === Functionconsole.log(Function.constructor === Function); // trueconsole.log(Object.constructor === Function); //true 9 . Function.prototype.__proto__ === Object.prototype Function是一个特殊的例子 他创造了所有的函数,但他自身就是也是一个函数 总不能自己创造自己吧 所以他的上级是 Object.prototype 下面配合几张原型图,帮助大家更好的理解. 构造函数创建对象字面量原型图1234 function Animal (color) &#123; this.color = color&#125;var dog = new Animal ('黑色') 当我们创建一个函数时原型如下: 完整对象字面量原型图1var obj = &#123; name: '陈二狗' &#125;; 数组原型链1var arr = ['第一个数','第二个数','第三个数'] 基本包装类型原型链1var str = new String('str') // var str = 'str' 其实所有的原型链规则都是根据上面的规则来的,只要能记住并理解,那么你也就理解原型了 如果有纰漏 忘指出,如果有转载,麻烦注明作者yucccc.]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端回流与重排]]></title>
    <url>%2F2017%2F07%2F18%2F%E5%89%8D%E7%AB%AF%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E6%8E%92%2F</url>
    <content type="text"><![CDATA[近日有一朋友去面试,遇到如下一道题目,要给一个dom元素循环添加一组dom元素,要放在循环内还是循环外,代码如下: 12345let div = document.getElementById('div')for (let i = 0 ; i &lt; 10 ; i++)&#123; // 每次遍历给div添加dom // 创建一个空白文档片段，给空白文档片段添加，最后再一次插入到div中&#125; 相信绝多数fe都知道要放在循环外 问 : 为什么？答：因为放在循环内会循坏的频繁的去操作dom问：频繁的操作dom有什么问题？答：因为每次都会去页面找这个dom,损耗性能问：dom 有唯一的id标识 所以并不存在这个问题？还有其他什么原因吗？答 : …. 很多人都仅仅知道不能频繁的操作dom，却不知道为什么频繁的去操作dom不好,另外有些人会以为因为每次都去查找dom，影响性能,其实重点不在这里，面试官主要的是考察你是否知道什么是重绘与回流 在讨论页面重绘、回流之前。需要对页面的呈现流程有些了解，页面是怎么把html结合css等显示到浏览器上的，可能不同的浏览器略微会有些不同。但基本上都是类似的。 页面如何把html结合css等显示到浏览器上 浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。 DOM Tree(树) 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，render tree能识别样式，render tree中每个node都有自己的style，而且 render tree不包含隐藏的节点 (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。注意 visibility:hidden隐藏的元素还是会包含到 render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据CSS2的标准，render tree中的每个节点都称为Box (Box dimensions)，理解页面元素为一个具有填充、边距、边框和位置的盒子。 一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。 回流与重绘 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 注意：回流必将引起重绘，而重绘不一定会引起回流。 回流何时发生：当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流： 1、添加或者删除可见的DOM元素； 2、元素位置改变； 3、元素尺寸改变——边距、填充、边框、宽度和高度 4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 5、页面渲染初始化； 6、浏览器窗口尺寸改变——resize事件发生时； 让我们看看下面的代码是如何影响回流和重绘的:1234567var s = document.body.style;s.padding = "2px"; // 回流+重绘s.border = "1px solid red"; // 再一次 回流+重绘s.color = "blue"; // 重绘s.backgroundColor = "#ccc"; // 重绘s.fontSize = "14px"; // 再一次 回流+重绘document.body.appendChild(document.createTextNode('abc!'));// 添加node，再一次 回流+重绘 说到这里大家都知道回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。 聪明的浏览器从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop/Left/Width/Height clientTop/Left/Width/Height width,height 请求了getComputedStyle(), 或者 IE的 currentStyle 当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。 如何减少回流、重绘 减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有： 直接改变className 1234567// 不好的写法var left = 1;var top = 1;el.style.left = left + "px";el.style.top = top + "px";// 比较好的写法el.className += " className"; 让要操作的元素进行”离线处理”，处理完后一起更新 使用DocumentFragment进行缓存操作,引发一次回流和重绘；可以参考这篇文章 了解DocumentFragment 给我们带来的性能优化 使用display:none技术，只引发两次回流和重绘；前面也提到,如果影响到页面布局就会导致回流 那么先把元素设置为 display:none 最后再 display:block 即可 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存 123456789101112131415// 别这样写for(循环) &#123;el.style.left = el.offsetLeft + 5 + "px";el.style.top = el.offsetTop + 5 + "px";&#125;// 这样写好点var left = el.offsetLeft,top = el.offsetTop,s = el.style; for (循环) &#123; left += 10; top += 10; s.left = left + "px"; s.top = top + "px"; &#125;]]></content>
      <tags>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用javascript小技巧]]></title>
    <url>%2F2017%2F06%2F08%2F%E5%B8%B8%E7%94%A8javascript%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[善于利用JS中的小技巧，不仅可以使代码更加简洁，而且逼格更高。 1.使用!!模拟Boolean()函数原理：逻辑非操作一个数据对象时，会先将数据对象转换为布尔值，然后取反，两个!!重复取反，就实现了转换为布尔值的效果。 2. 使用一元加(+)模拟Number()函数原理：对非数值类型的数据使用一元加(+)，会起到与Number()函数相同的效果。 null转换为0 undefined转换为NaN false转换为0，true转换为1 对于字符串： 空字串转换为0 含有数字或者浮点数或者十六进制格式的数据(11, 0.3, 0xfe等)，转换为相应的数值 含有其他格式字符，无法转换为数值的字符串，转换为NaN 对于对象，先调用valueOf()方法，在转换，若结果为NaN，那么再调用toString()方法，之后再转换 3.使用逻辑与(&amp;&amp;)进行短路操作123if(connected)&#123; login();&#125; 以上代码可以简写为:1connected &amp;&amp; login(); 也可用这种方法来检查对象中是否拥有某个属性1user &amp;&amp; user.name 原理：逻辑与(&amp;&amp;)会首先对第一个操作数进行求值，只有求值结果为true时才会对第二个操作数求值。connected &amp;&amp; login()中，若判断connected不为true,则不再进行下一步操作。所谓的短路操作即第一个操作数可以决定结果，则不再对第二个操作数进行求值。 4. 使用逻辑或(||)设置默认值逻辑或(||)也属于短路操作，即当第一个操作数可以决定结果时，不再对第二个操作数进行求值。利用这个特点，我们可以给赋值语句设置默认值。只有当第一个操作数为null或者undefined时，才会把第二个操作数赋值给目标。123function User(name, age)&#123; this.name = name || "Liming";&#125; 上述代码中，如果函数中没有传入name参数，name的值为undefined，那么就会给this.name赋值为”Liming”。ES6中可以为函数设置默认值，所以这种方法可能要成为过去式，但是其他地方还是很有用的。ES6 写法 简洁了许多1let User = (name="Liming", age) =&gt; &#123; &#125; 5. 获取数组最后n个元素可以使用以下代码获取数组中最后n个元素123var array = [1, 2, 3, 4, 5, 6];console.log(array.slice(-1)); //[6]console.log(array.slice(-2)); //[5, 6] 原理:Array.prototype.slice(begin,end)可以用来裁剪数组，第二个参数的默认值是数组的长度值。若值传入一个参数，则会返回从指定索引开始到数组结尾的所有值。而slice()方法还可以接收负值，当传入负值时，会自动加上数组的长度值使其转换为正值，于是便得到了最后的n个值。 6. 合并大数组常用的合并数组的方式是使用Array.concat()函数。该函数会创建一个新数组，将两个数组连接起来存储到新数组中，这会大量消耗内存。可以使用Array.push.apply(arr1, arr2)，它不会创建新数组，而是将第二个数组合并到第一个数组中，以减少内存的消耗。123456var a = [1,2];var b = [3,4];console.log(a.push.apply(a, b)); // [1,2,3,4]//或者Array.prototype.push.apply(a, b); // a变成了[1,2,3,4]console.log(a); //[1,2,3,4] 原理: Array.push()是在数组的末尾增加元素，但是如果使用a.push(b)会把整个数组b当作一个元素添加到数组a中。而apply()方法，则允许将某个方法的参数以数组的形式传入，所以起到了将数组b中的元素追加到数组a中的效果。 7. NodeList转换为数组使用document.querySelectorAll(‘div’)返回的是NodeList对象，虽然它很像数组，但是并不能使用诸如sort()，filter()等方法。你可以将其转换为真正的数组。123456var eles = document.querySelectorAll('p'); //NodeListvar arrayElements = [].slice.call(eles); //转化为数组// 或者var arrayElements = Array.prototype.slice.call(eles);// 或者var arrayElements = Array.from(eles); 原理: [].slice.call(eles):首先创建了一个空数组[]，然后调用他的slice()方法，但是在slice()方法的执行中，把this对象指向了eles,所以会对eles进行裁减，由于对slice()方法没有传入参数，所以相当于slice(0,eles.length),会按照元长度返回一个数组。 Array.prototype.slice.call(eles): 原理与上面相似，只不过这次没有创建空数组，而是直接使用了原型中的方法]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2监听微信返回按钮仿微信切换动画]]></title>
    <url>%2F2017%2F06%2F06%2Fvue2%E7%9B%91%E5%90%AC%E5%BE%AE%E4%BF%A1%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[效果如下点击了浏览器默认返回按钮执行后退动画 其他执行前进动画 这里录制的时候没录制到鼠标轨迹大致思路如下:在vue中实现动画其实是很简单的,但是由于网上查找不到相关的浏览器默认返回按钮或者微信的返回按钮事件，所有只能是一个伪的监测返回事件代码如下： 首先是先定义css动画 感谢vux的源码 我是一顿复制粘贴app.vue 文件 123456789101112131415161718192021.vux-pop-out-enter &#123; opacity: 0; transform: translate3d(-100%, 0, 0);&#125;.vux-pop-out-leave-active &#123; opacity: 0; transform: translate3d(100%, 0, 0);&#125;.vux-pop-in-enter &#123; opacity: 0; transform: translate3d(100%, 0, 0); -webkit-transform: translate3d(100%, 0, 0);&#125;.vux-pop-in-leave-active &#123; opacity: 0; transform: translate3d(-100%, 0, 0); -webkit-transform: translate3d(-100%, 0, 0);&#125; 定义动画执行组件 此处的name应该是动态改变的app.vue 文件 123&lt;transition :name="'vux-pop-'+ animate"&gt; &lt;router-view class="router-view"&gt;&lt;/router-view&gt;&lt;/transition&gt; 定义name的值 那么此时我们需要用到vuex 如果你用其他也可以 个人习惯用vuexmain.js 文件 1234567891011const store = new Vuex.Store(&#123;&#125;);//也许这里你已经有其他vuex模块store.registerModule('vux', &#123; // 名字自己定义 state: &#123; animate: 'in', // 动画状态 默认是进入 &#125;, mutations: &#123; // 提交状态 animateChange(state, payload)&#123; state.animate = payload.animate &#125; &#125;&#125;); 重点来了 改变animate的状态 我们需要监测路由的状态main.js 文件 1234567891011121314var routerArr = [];// 创建一个存储路由数组router.beforeEach(function (to, from, next) &#123; routerArr.push(to.path);//每次push路由 if (routerArr[routerArr.length - 3] === to.path) &#123;// 当如果要去的路径等于数组的倒数第二个路由 那么就是点 击了后退 store.commit('animateChange', &#123; animate: 'out' // 变成后退动画 &#125;); routerArr.splice(routerArr.length - 2, 2) // 必须删除数组的倒数两位字符串 &#125; else &#123; store.commit('animateChange', &#123; animate: 'in' // 变成前进动画 &#125;); &#125;&#125; 这么做的话就可以实现切换的效果了 但是存在刷新数组被情况的情况 改成存在sessionStorage 里面就可以 最后拿到 animate 状态app.vue 文件123456import &#123;mapState&#125; from 'vuex' computed: &#123; ...mapState(&#123; animate: state =&gt; state.vux.animate // 拿到状态 &#125;) &#125; 也许有更好的解决办法 目前只能这么实现了]]></content>
      <categories>
        <category>vue2</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2微信分享坑点]]></title>
    <url>%2F2017%2F06%2F06%2Fvue2%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E5%9D%91%E7%82%B9%2F</url>
    <content type="text"><![CDATA[现在我的需求是在首页或者详情页点击分享 成功之后会请求后端接口 如果符合条件 则会得到一张 首先 肯定是先撸一波文档 微信api接口文档微信分享其实很简单 步骤如下 绑定域名先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。这个不多说，见文档，只有绑定了才能进行下一步的动作 引入js文件此处我用的是vux内置的插件 其他方式正常引入script即可 123import &#123; WechatPlugin&#125; from 'vux'Vue.use(WechatPlugin); // 微信const wx = Vue.wechat; 通过config接口注入权限验证配置所有需要使用JS-SDK的页面必须先注入配置信息 配置信息需要后端返回 123456789101112131415161718192021222324// 此处我是定义在vue原型中 这样方便以后的调用 通过 this.wxShare()调用const imgUrl = 'http://xxx.xxxx.xxxx'; // 测试地址Vue.prototype.wxShare = function (title, desc, link) &#123; const url = document.location.href;// 当前url http.get(getConfig(), &#123;//请求配置 params: &#123; url: url &#125; &#125;).then(res =&gt; &#123;// 获得签名配置 var Data = res.data.data; // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作 wx.config(&#123; debug: false, // 开启调试模式,开发时可以开启 appId: Data.appid, // 必填，公众号的唯一标识 由接口返回 timestamp: Data.timestamp, // 必填，生成签名的时间戳 由接口返回 nonceStr: Data.nonceStr, // 必填，生成签名的随机串 由接口返回 signature: Data.signature, // 必填，签名 由接口返回 jsApiList: ['onMenuShareAppMessage', 'onMenuShareTimeline'] // 此处填你所用到的方法 &#125;); &#125;);wx.ready(() =&gt;&#123;// ..... code&#125;&#125;; 定义方法12345678910111213141516171819202122232425262728293031323334Vue.prototype.wxShare = function (title, desc, link) &#123;wx.config()wx.ready(() =&gt; &#123; // 所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口， // 则可以直接调用，不需要放在ready函数中。 wx.onMenuShareAppMessage(&#123; // 分享给朋友 title: title, // 分享标题 desc: desc, // 分享描述 link: link, // 分享链接 默认以当前链接 imgUrl: imgUrl + '/static/images/share.png',// 分享图标 // 用户确认分享后执行的回调函数 success: function () &#123; var params = new URLSearchParams(); params.append('token', window.localStorage.getItem('token')); params.append('type', 'share'); http.post(shareCallback(), params).then(res =&gt; &#123; // 请求后端分享成功之后获取一票的接口 if (res.data.error == 0) &#123; // 表示当天分享成功 store.commit('shareChange', &#123;// vuex弹出分享成功获取一票 isShare: true &#125;); &#125; else &#123; return; &#125; &#125;) &#125;, // 用户取消分享后执行的回调函数 cancel: function () &#123; console.log('分享到朋友取消'); &#125; &#125;); //分享到朋友圈 wx.onMenuShareTimeline(&#123;&#125;); &#125;);&#125;; 然后在需要的钩子里面调用即可,以上的流程都可以在文档中查看 坑点 在ios微信浏览器中 window.onload.reload() 以及 window.location.go(0) 无效我想实现登陆之后刷新页面, 结果在登陆之后 ios并不会刷新页面解决办法： 最后使用 watch 解决 1234567watch: &#123; login: function () &#123; if (this.login) &#123; this._getFansCard() &#125; &#125;&#125; ios上二次分享会出现签名错误, 并且莫名被拼接上了一串标识 此问题只有在ios上有 ios会在#号中间添加一串标识 如下 12http://test.aaa.bbbb.com/?from=singlemessage&amp;isappinstalled=0#/details?id=2// 原本链接 http://test.aaa.bbbb.com/#/details?id=2 这个问题解决了两天,建议在一开始就开启debug模式,这样能及时知道问题所在解决办法:一开始以为是 ‘#’ 的问题 于是乎开启vue HTML5 History 模式 去除掉# 结果发现 在进入其他页面的时候 复制连接还是首页的链接 本质上还是没得到解决后来发现本质上的错误是;当浏览者从分享窗口进入后，他从分享页按着正常路由跳转到其他页面，其他页面的逻辑中如果有需要获取当前页面url的需要，会发现这个url和正常路由跳转的不一样,导致签名不一致,所以获取不到正确的文案。最后我是隔天再次测试就好了,最终我也不知道是到底如何解决的。。。。一开始 有 # 然后开启 h5模式 最后又还原了 哈希模式 发现二次分享的问题解决了。。。。]]></content>
      <categories>
        <category>vue2</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2动态给微信单页应用更改标题]]></title>
    <url>%2F2017%2F04%2F30%2Fvue2%E5%8A%A8%E6%80%81%E7%BB%99%E5%BE%AE%E4%BF%A1%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E6%9B%B4%E6%94%B9%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[现在公司项目的重构,用到的是vue2.0,做的是一个微信m站,但是由于是SPA单页应用,所以就没有所谓的页面 都是router的跳转而网页的标题 随着路由的改变而改变 也就成了一个(伪)需求 问题在iOS的微信中 一个SPA应用 想要改变微信顶部导航栏的标题 使用document.title = xxx来改变网页标题是无效的原因大致就是因为在微信中webview只加载网页标题一次 动态改变是无效的 除非都以新页面打开 解决方法在网上查阅的资料都是说vue1的解决方法,并没有一个vue2的相关解决方法,因为2中的router与1发生变化,那么哪些解决方法也就不适用了,下面是本人使用的vue2的解决办法代码如下 先创建一个方法 这里我是放在utils文件夹中起名为setWechatTitle.js 123456789101112131415161718/** * Created by yccc on 2017/4/30. */module.exports = function (title) &#123; document.title = title; let ua = navigator.userAgent; if (/\bMicroMessenger\/([\d\.]+)/.test(ua) &amp;&amp; /ip(hone|od|ad)/i.test(ua)) &#123; var i = document.createElement('iframe'); i.src = '/favicon.ico'; i.style.display = 'none'; i.onload = function () &#123; setTimeout(function () &#123; i.remove(); &#125;, 9); &#125;; document.body.appendChild(i); &#125;&#125;; main.js 12345678910111213141516 import setWechatTitle from './utils/setWechatTitle.js' // 导入方法 //.....some code import router from './router' // 导入的路由 new Vue(&#123; // vue实例 el: '#app', router, store, template: '&lt;App/&gt;', components: &#123;App&#125; &#125;)// router.beforeEach((to, from, next) =&gt; &#123; typeof to.meta.pageTitle !== undefined &amp;&amp; setWechatTitle(to.meta.pageTitle) next() //确保要调用 next 方法，否则钩子就不会被 resolved。 &#125;) 至此只需要在route中加入meta属性即可 router/ index.js1234567&#123; // 我的 path: '/my', component: (reslove) =&gt; require(['../views/My/my.vue'], reslove), meta: &#123; pageTitle: '我的页面' &#125;&#125; 可以在手机微信上检验效果]]></content>
      <categories>
        <category>vue2</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2绑定内联样式background的一些坑]]></title>
    <url>%2F2017%2F04%2F11%2Fvue2%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8Fbackground%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[此时我有一个需求，给一个盒子添加一个背景图片，这个背景图片是动态请求回来的，那么应该怎么做？看似简单，其实很考研对JavaScript基础的功底以及对vue生命周期的理解。正常情况下的vue内联样式如下写法： 12345&lt;div :style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;data: &#123; activeColor: 'red', fontSize: 30&#125; 此时的style绑定的是一个JavaScript对象，在JavaScript中不允许出现 “-“ ，那么绑定一个背景图片应该这么写：1234&lt;div :style="&#123;background: 'url('+ img +')'，backgroundSize:cover &#125;"&gt;&lt;/div&gt;data:&#123; img:'xxx.png'&#125; 好了背景图片已经成功通过字符串拼接的方式加上了，我们改为动态请求回来的。12345678910111213141516&lt;div :style="&#123;background: 'url('+ img +')'，backgroundSize:cover &#125;"&gt;&lt;/div&gt;data:&#123; img:'xxx.png'&#125;,methods:&#123;// 伪代码 请求数据 getImg()&#123; this.$http.get().then(function (e) &#123; this.img = e.data //将数据赋值给img &#125;.bind(this)) &#125;&#125;，created()&#123;// 调用函数 this.getImg()&#125; created vue2生命周期钩子函数在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定data，计算属性computed，方法methods，watcher/事件回调。此时你会发现虽然渲染了出来，但是报错了12Error in render functionCannot read property &apos;img&apos; of undefined 因为在生命周期 mounted 之前都是虚拟dom 也就是说 当页面已经渲染完，但是vue还没执行，所有数据丢失，此时我们加上1&lt;div v-if='img ' :style="&#123;background: 'url('+ img +')'，backgroundSize:cover &#125;"&gt;&lt;/div&gt; 表示有img属性的时候我们选择这个元素,至此就成功绑定背景图片了。]]></content>
      <categories>
        <category>vue2</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb Windows环境安装及配置]]></title>
    <url>%2F2017%2F04%2F10%2Fmongodb%20Windows%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[因为最近要用 mongodb+node.js+vue2做一个小demo,所以第一步应该是先安装好mongodb,本以为是十分简单的安装,却踩了不少坑。 下载先到官网下载mongodb 点击到官网 选择合适自己的版本,我用的是window 所以下的window版本,此时的mongodb版本为3.4 安装一直点下一步,直到这里，我选择的是custom自定义安装.在E盘根目录下创建了一个MongoDB文件夹,安装在E盘的根目录下 E:\MongoDB文件夹中,要安装在哪里随你便,但是建议放在根目录下，并且记得你安装在哪，等会有用。此时你会看到如下文件创建数据库目录E:\MongoDB\data，接下来打开命令行窗口，切换到E:\MongoDB\bin 目录执行如下命令： mongod --dbpath E:\MongoDB\data–dbpath 指定数据库路径 创建的data是用来存放数据的此时如果最后一行出现（视情况而定,最后是 on port 27017 ）即为成功2017-04-10T21:14:16.257+0800 I NETWORK [thread1] waiting for connections on port 27017在浏览中输入：http://localhost:27017如果出现 It looks like you are trying to access MongoDB over HTTP on the native driver port. 代表成功安装了。但是你会发现，这样十分的麻烦，每次需要指定数据库，并且需要跑到目录下开启数据库，接下来就是将MongoDB安装为Windows服务 配置window服务1:在E:\mongodb\data下新建文件夹log（存放日志文件）并且在里面新建文件mongodb.log2:在E:\mongodb中新建文件mongo.config,用记事本打开并在mongo.config中输入12dbpath=E:\mongodb\data logpath=E:\mongodb\log\mongo.log dppath 代表数据库存放路径logpath 代表日志存放路径如图 重点来了**以管理员身份运行cmd命令行,记得一定要用管理员身份运行,不然会出问题，右击以管理员身份运行,进入E:\mongodb\bin目录，如果你此时在c盘下可以输入命令：1cd E:\MongoDB\bin 你会发现并没切换到E盘 再次输入1E: 就可以切换到 E:\MongoDB\bin 目录下输入如下的命令：1mongod --config E:\mongodb\mongo.config --install --serviceName &quot;MongoDB&quot; 如果输出了日期，代表成功了，没输入可以重复上面命令，或者你没用管理员身份运行 打开cmd输入services.msc查看服务找到MongoDB服务，点击启动即可，至此你就成功安装了mongodb并且开机自动启动]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueX在ie,safari浏览器无法解析的解决方法]]></title>
    <url>%2F2017%2F04%2F08%2FVueX%E5%9C%A8ie-safari%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天在做一个vue2项目时,引入了vuex做一些状态管理，结果调试发现在ie11以下页面显示不出来，打开控制台发现出现如下错误： 1[vuex] vuex requires a Promise polyfill in this browser. 意思为vuex需要在这个浏览器上解析不了 因为vuex基于promise, IE浏览器没有内置Promise对象那么此时我们需要一个解析promise ES6语法的东西。不仅如此，几乎所有的ES6新增的方法在IE都不能用，比如Array.from。因为babel只会转译语法，并不会新增方法。此时你需要babel Polyfill polyfillpolyfill是一种js库，为低版本的js环境补足高版本js里定义的一些原生功能 用法十分简单如下：1：下载1npm install --save babel-polyfill 2 :方法一 ：在main.js最顶部加入1import 'babel-polyfill';//解决ie浏览器不支持promise 方法二：或者在webpack中加入12345678module.exports = &#123; // entry: &#123; // 这是原本脚手架配置的 // app: './src/main.js' // &#125;, entry: &#123; // 替换成 app: ['babel-polyfill','./src/main.js'] &#125;,&#125; 这种需要重新npm run dev 因为更改了webpack的配置两种加入方法都可以解决，个人建议第一种方便快捷，此时重新打开浏览器项目就能正常解析了。]]></content>
      <categories>
        <category>vue2</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2中注册在router-link上事件无效解决方法]]></title>
    <url>%2F2017%2F04%2F06%2FVue2%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%9C%A8router-link%E4%B8%8A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天用vue在做一个tab栏切换的时候，偶然发现我绑定在router-link上的click并不会触发，后来测试发现，所有绑定在router-link中的事件都不会促发此后查看了官方的文档，也并没有给出明确的说明：代码如下： 1&lt;router-link @click="change"&gt;&lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; 此刻我发现，无论如何定义在methods 中的 change函数并不会触发，这是为什么呢？在github查看了vue-router的代码后发现： 事件被阻止如果当前router-link的tag不是a的话（官方文档中说明：默认为a，可以通过tag改变渲染后的标签），那么就会往自己的子元素（组件）找，找到的第一个就会把一些属性及时间覆盖过去。所以此时事件是被阻止了。个人看法：因为router-link的作用是单纯的路由跳转，如果不阻止事件的话，也许会有很多坑，所以作者干脆阻止了其他事件的触发 如何解决1&lt;router-link @click.native="change"&gt;&lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; 只需要在@click后面加上native就可以了 原生事件添加native事件修饰符之后变为原生事件1$element.addEventListener(click, callback); 此时a标签并不会阻止，至此便可以解决绑定在router-link身上的事件不会触发的问题。其次，想要实现tab切换添加class可以在router中添加如下配置：1234export default new Router(&#123; routes: [],// 路由跳转配置 linkActiveClass:'active' // 在路由中添加配置 active 为跳转到该路由时添加的激活类名&#125;)]]></content>
      <categories>
        <category>vue2</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2搭建开发环境并且可以请求本地数据设置]]></title>
    <url>%2F2017%2F04%2F04%2Fvue2%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这一个问题困扰了我许久，怎么用vue搭建开发环境并且可以请求本地数据，因为webpack-dev-server在编译vue的时候会默认开启一个端口，本地的服务器肯定也会拥有一个端口，那么不同端口的请求又为跨域请求，此时又不能把端口改为相同，因为这样会造成端口冲突，当然不考虑跨域jsonp之类，虽然jsonp可以做，但是在开发中无疑增加了繁杂度，并且这样做的话上线又要改请求方式，十分麻烦，那么应该怎么做呢？ 这时候就要用到webpack里面的开启代理的配置,即把请求的地址转发到指定的地址，并且允许跨域请求 如下： 开启webpack代理此时找到config文件中的index.js,拉到底部找到dev：{ 里面是一些端口的配置} 在里面添加上如下配置 1234567891011121314151617 dev: &#123; env: require('./dev.env'), port: 9999, autoOpenBrowser: true, assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: &#123;// 这里用的是vue-cli脚手架,默认proxyTable:&#123;&#125; ,内容为空 只需要配置这个参数即可 '/webapi': &#123;//代表你以什么为开始请求数据 表示以webapi开头的请求就开启代理 target: 'http://im.ivymei.com', //代表代理地址 即：如果 this.$http.get('/webapi').then() 此时会变成http://www.baidu.com/webapi changeOrigin: true,// 表示允许跨域 pathRewrite: &#123; '^/webapi': '/webapi' //可要可不要 &#125; &#125; &#125;, cssSourceMap: false,&#125; 至此就可以愉快的请求本地数据了 8080端口也能请求80端口的数据了 最终打包上线也不需要改任何代码,更多的webpack代理设置请查阅webpack官方文档]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一些开发中常用css3属性]]></title>
    <url>%2F2016%2F09%2F23%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8css3%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.超出变成省略号text-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出。text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，必须配合强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），并且需要给出只宽度(width),只有这样才能实现溢出文本显示省略号的效果，代码如下 123456.test_demo&#123; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; width:200px;&#125; 2.移动端惯性回弹效果很多时候,在做一些导航需要栏可以左右拉动的时候，我们会选择一些滚动的插件或者直接overflow:scroll 引入插件固然能解决问题，但是我们有时候仅仅需要使用一次,未免过于浪费,overflow固然可以解决问题，但是用户体验极差，拉动效果生硬，如何增加一个弹簧的效果，其实只需要加一个属性 1-webkit-overflow-scrolling:touch; // 允许独立的滚动区域和触摸回弹]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发常见问题（三）]]></title>
    <url>%2F2016%2F06%2F10%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[关闭iOS输入自动修正 和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉：1&lt;input type="text" autocorrect="off" /&gt; 禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：123html &#123; -webkit-text-size-adjust: 100%;&#125; 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 meta viewport。 移动端如何清除输入框内阴影在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：1234input,textarea &#123; border: 0; /* 方法1 */ -webkit-appearance: none; /* 方法2 */&#125; 快速回弹滚动我们先来看看回弹滚动在手机浏览器发展的历史： 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll; Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动； Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除； iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：1234.xxx &#123; overflow: auto; /* auto | scroll */ -webkit-overflow-scrolling: touch; &#125; PS：iScroll用过之后感觉不是很好，有一些诡异的bug，这里推荐另外一个 iDangero Swiper，这个插件集成了滑屏滚动的强大功能（支持3D），而且还有回弹滚动的内置滚动条。iDangero官方地址： http://www.idangero.us/swiper/#.VX_t9PmEB8Y 移动端禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：12345.user-select-none &#123; -webkit-user-select: none; /* Chrome all / Safari all */ -moz-user-select: none; /* Firefox all （移动端不需要） */ -ms-user-select: none; /* IE 10+ */ &#125; 移动端取消touch高亮效果在做移动端页面时，会发现所有a标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过css以下方法来进行全局的禁止：123html &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 但这个方法在三星的机子上无效，有一种妥协的方法是把页面非真实跳转链接的a标签换成其它标签，可以解决这个问题。 如何禁止保存或拷贝图像（IOS）通常当你在手机或者pad上长按图像 img ，会弹出选项存储图像 或者拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：1img &#123; -webkit-touch-callout: none; &#125; 模拟按钮hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue:active&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btn-blue"&gt;按钮&lt;/div&gt;&lt;script type="text/javascript"&gt;document.addEventListener("touchstart", function()&#123;&#125;, true)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;兼容性ios5+、部分android 4+、winphone 8要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名。&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123; display:block; height:42px;line-height:42px; text-align:center;border-radius:4px; font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue-on&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="btn-blue"&gt;按钮&lt;/div&gt;&lt;script type="text/javascript"&gt;var btnBlue = document.querySelector(".btn-blue");btnBlue.ontouchstart = function()&#123; this.className = "btn-blue btn-blue-on"&#125;btnBlue.ontouchend = function()&#123; this.className = "btn-blue"&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 屏幕旋转的事件和样式事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式1234567891011window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert("横屏:" + window.orientation); case 0: case 180: alert("竖屏:" + window.orientation); break; &#125;&#125; 样式123456789//竖屏时使用的样式@media all and (orientation:portrait) &#123; .css&#123;&#125;&#125;//横屏时使用的样式@media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播123$('html').one('touchstart',function()&#123; audio.play()&#125;) 摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 手机拍照和上传图片12345&lt;input type="file"&gt;的accept 属性&lt;!-- 选择照片 --&gt;&lt;input type=file accept="image/*"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept="video/*"&gt; 使用总结： iOS有拍照、录像、选取本地图片功能 部分android只有选取本地图片功能 winphone不支持 input控件默认外观丑陋 消除transition闪屏123456.css&#123; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden;&#125; 开启硬件加速 解决页面闪白 保证动画流畅123456.css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 设计高性能CSS3动画的几个要素 尽可能地使用合成属性transform和opacity来设计CSS3动画 不使用position的left和top来定位 利用translate3D开启GPU加速 android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125; 常用框架移动端基础框架 zepto.js语法与jquery几乎一样，会jquery基本会zepto； iscroll.js解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能； underscore.js该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象； fastclick加快移动端点击响应时间 animate.css CSS3动画效果库滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果 slip.js iSlider.js fullpage.js瀑布流框架 masonry工具推荐 caniuse 各浏览器支持html5属性查询 paletton 调色搭配]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发常见问题（二）]]></title>
    <url>%2F2016%2F06%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[移动端如何定义字体font-family 三大手机系统的字体： iOS 系统 默认中文字体是Heiti SC 默认英文字体是Helvetica 默认数字字体是HelveticaNeue 无微软雅黑字体 Android 系统 默认中文字体是Droidsansfallback 默认英文和数字字体是Droid Sans 无微软雅黑字体 Winphone 系统 默认中文字体是Dengxian(方正等线体) 默认英文和数字字体是Segoe 无微软雅黑字体 各个手机系统有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持。移动端定义字体的代码body{font-family:Helvetica;} 移动端字体单位font-size选择px还是rem 对于只需要适配手机设备，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备rem配置参考：12345678910111213141516171819202122232425262728293031323334353637&lt;!--这个网上有许多 根据自己的需求来 --&gt;html &#123;font-size:10px&#125;@media screen and (min-width:480px) and (max-width:639px) &#123; html &#123; font-size: 15px &#125;&#125;@media screen and (min-width:640px) and (max-width:719px) &#123; html &#123; font-size: 20px &#125;&#125;@media screen and (min-width:720px) and (max-width:749px) &#123; html &#123; font-size: 22.5px &#125;&#125;@media screen and (min-width:750px) and (max-width:799px) &#123; html &#123; font-size: 23.5px &#125;&#125;@media screen and (min-width:800px) and (max-width:959px) &#123; html &#123; font-size: 25px &#125;&#125;@media screen and (min-width:960px) and (max-width:1079px) &#123; html &#123; font-size: 30px &#125;&#125;@media screen and (min-width:1080px) &#123; html &#123; font-size: 32px &#125;&#125; 移动端touch事件(区分webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 以下支持winphone 8 MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action:none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp——当手指离开屏幕时触发 移动端click屏幕产生200-300 ms的延迟响应移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。以下是历史原因： 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放 (double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速 双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是 单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则 浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有 多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说 是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题触摸事件的响应顺序1、ontouchstart2、ontouchmove3、ontouchend4、onclick解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应。 什么是Retina 显示屏，带来了什么问题retinaretina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下1.css&#123;width:100px;height:100px;background-size:100px 100px;&#125; //其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px1.css&#123;font-size:20px&#125; ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。1a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)&#125; 部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果。1234a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; &#125; -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符。另外，有些机型去除不了，如小米2对于按钮类还有个办法，不使用a或者input标签，直接用div标签 winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name="msapplication-tap-highlight" content="no"&gt; webkit表单元素的默认外观怎么重置1.css&#123;-webkit-appearance:none;&#125; webkit表单输入框placeholder的颜色值能改变么12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:red&#125; webkit表单输入框placeholder的文字能换行么 iOS可以，Android不行 关闭iOS键盘首字母自动大写在iOS中，默认情况下键盘是开启首字母大写的功能的，如果启用这个功能，可以这样：1&lt;input type="text" autocapitalize="off" /&gt;]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发常见问题（一）]]></title>
    <url>%2F2016%2F06%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Meta相关 添加到主屏后的标题（IOS）1&lt;meta name="apple-mobile-web-app-title" content="标题"&gt; 启用 WebApp 全屏模式（IOS）当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）12&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;meta name="apple-touch-fullscreen" content="yes" /&gt; 百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：1&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt; 设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在”apple-mobile-web-app-capable” content=”yes”时生效1&lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /&gt; content 参数： default ：状态栏背景是白色。 black ：状态栏背景是黑色。 black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 移动端手机号码识别（IOS）在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如： 7位数字，形如：1234567 带括号及加号的数字，形如：(+86)123456789 双连接线的数字，形如：00-00-00111 11位数字，形如：13800138000 可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：123456关闭电话号码自动识别&lt;meta name="format-detection" content="telephone=no" /&gt;开启电话功能&lt;a href="tel:123456"&gt;123456&lt;/a&gt;开启短信功能：&lt;a href="sms:123456"&gt;123456&lt;/a&gt; 移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来关闭邮箱的自动识别：1234关闭邮箱的自动识别&lt;meta content="email=no" name="format-detection" /&gt; 开启长按邮箱地址弹出邮件发送的功能：&lt;a mailto:dooyoe@gmail.com"&gt;dooyoe@gmail.com&lt;/a&gt; 添加智能 App 广告条 Smart App Banner（IOS 6+ Safari）1&lt;meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"&gt; IOS Web app启动动画由于iPad 的启动画面是不包括状态栏区域的。所以启动图片需要减去状态栏区域所对应的方向上的20px大小，相应地在retina设备上要减去40px的大小。123456789101112&lt;link href="apple-touch-startup-image-320x460.png" media="(device-width: 320px)" rel="apple-touch-startup-image"&gt;&lt;link href="apple-touch-startup-image-640x960.png" media="(device-width: 320px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"&gt;&lt;link href="apple-touch-startup-image-768x1004.png" media="(device-width: 768px) and (orientation: portrait)" rel="apple-touch-startup-image"&gt;&lt;link href="apple-touch-startup-image-748x1024.png" media="(device-width: 768px) and (orientation: landscape)" rel="apple-touch-startup-image"&gt;&lt;link href="apple-touch-startup-image-1536x2008.png" media="(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"&gt;&lt;link href="apple-touch-startup-image-2048x1496.png" media="(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"&gt;（landscape：横屏 | portrait：竖屏） 添加到主屏后的APP图标指定web app添加到主屏后的图标路径，有两种略微不同的方式：1234&lt;!-- 设计原图 --&gt;&lt;link href="short_cut_114x114.png" rel="apple-touch-icon-precomposed"&gt;&lt;!-- 添加高光效果 --&gt;&lt;link href="short_cut_114x114.png" rel="apple-touch-icon"&gt; apple-touch-icon：在IOS6及以下的版本会自动为图标添加一层高光效果（IOS7开始已使用扁平化的设计风格） apple-touch-icon-precomposed：使用“设计原图图标” 图标尺寸：可通过指定size属性来为不同的设备提供不同的图标（但通常来说，我们只需提供一个114 x 114 pixels大小的图标即可 ） 官方说明如下：Create different sizes of your app icon for different devices. If you’re creating a universal app, you need to supply appicons in all four sizes.For iPhone and iPod touch both of these sizes are required:57 x 57 pixels114 x 114 pixels (high resolution)For iPad, both of these sizes are required:72 x 72 pixels144 x 144 (high resolution) 优先使用最新版本 IE 和 Chrome1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; viewport模板123456789101112131415&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;title&gt;标题&lt;/title&gt;&lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常见的表单输入限制方法代码]]></title>
    <url>%2F2016%2F04%2F22%2Fjavascript%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E9%99%90%E5%88%B6%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[近期公司在做一个后台管理系统,各种要限制输入,网上资料虽有，但是比较散乱，个人收集一些常用的表单限制代码1.文本框只能输入数字代码(小数点也不能输入)1&lt;input onkeyup="this.value=this.value.replace(/\D/g,'')" onafterpaste="this.value=this.value.replace(/\D/g,'')"&gt; 2.只能输入数字,能输小数点12&lt;input onkeyup="if(isNaN(value))execCommand('undo')" onafterpaste="if(isNaN(value))execCommand('undo')"&gt;&lt;input onchange="if(/\D/.test(this.value))&#123;alert('只能输入数字');this.value='';&#125;" name=txt1&gt; 3.只能输入字母和汉字1&lt;input onkeyup="value=value.replace(/[\d]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[\d]/g,''))" maxlength=10 name="Numbers"&gt; 4.只能输入英文字母和数字,不能输入中文1&lt;input onkeyup="value=value.replace(/[^\w\.\/]/ig,'')"&gt; 5.只能输入数字和英文1&lt;input onKeyUp="value=value.replace(/[^\d|chun]/g,'')"&gt; 6.小数点后只能有最多两位(数字,中文都可输入),不能输入字母和运算符号1&lt;input onKeyPress="if((event.keyCode&lt;48 || event.keyCode&gt;57) &amp;&amp; event.keyCode!=46 || /\.\d\d$/.test(value))event.returnValue=false"&gt; 7.小数点后只能有最多两位(数字,字母,中文都可输入),可以输入运算符号1&lt;input onkeyup="this.value=this.value.replace(/^(\-)*(\d+)\.(\d\d).*$/,'$1$2.$3')"&gt; 8.只能输入中文：1&lt;input name="realname" type="text" maxlength="20" class="input_style" value="" onkeyup="value=value.replace(/[^\u4E00-\u9FA5]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\u4E00-\u9FA5]/g,''))" /&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[限制H5 date日期控件所选日期不能晚于当前日期]]></title>
    <url>%2F2016%2F04%2F10%2F%E9%99%90%E5%88%B6H5inputtype-date%E6%97%A5%E6%9C%9F%E6%8E%A7%E4%BB%B6%E6%89%80%E9%80%89%E6%97%A5%E6%9C%9F%E4%B8%8D%E8%83%BD%E6%99%9A%E4%BA%8E%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[道理其实很简单 只需要限制 max = ‘当前日期即可’1&lt;input type="date" name="" value="" max="当前日期" class='limit-max-date'&gt; 那么只需要动态设置max值即可 一定要遵循 YYYY-MM-DD 123456789101112131415161718// 获取input var input1 = document.querySelector('.limit-max-date');// 获取当前日期var tDate = (function()&#123; var date = new Date(); var seperator1 = "-"; var month = date.getMonth() + 1;//月 var strDate = date.getDate();//日 if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = "0" + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = "0" + strDate; &#125; return date.getFullYear() + seperator1 + month + seperator1 + strDate&#125;)()input1.setAttribute('max',tDate)// 设置max值为当前日期 至此就不能选择比今天更晚的日期,一般用于选择生日时间。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现jQuery中的type检测数据类型]]></title>
    <url>%2F2016%2F03%2F20%2FJavaScript%E5%AE%9E%E7%8E%B0jQuery%E4%B8%AD%E7%9A%84type%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[众所周知，JavaScript中的typeof虽然可以检测数据类型，但是在检测数据类型的时候,返回的数据类型不一定准确:比如 null 也会返回null ，返回的数据类型只有下面几种，远远不能准确的判断属于何种数据类型。 123456"undefined" ——如果这个值未定义；"boolean" ——如果这个值是布尔值；"string" ——如果这个值是字符串； "number" ——如果这个值是数值；"object" ——如果这个值是对象或 null ；"function" ——如果这个值是函数。 在网上也看了一些所谓的全面的检测方法，也没有很好的实现封装。无聊之余看了下jQuery的type实现方法，现在我用JavaScript实现一下。 1234567891011121314151617//定义一个对象保存所有的数据类型 var class2type = &#123;&#125;; var dataType = "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "); //把所有的数据类型遍历进class2type里面 jQuery中用的是自己封装的each forEach() 是es5新增的方法 dataType.forEach(function (name, i) &#123; class2type["[object " + name + "]"] = name.toLowerCase(); &#125;) var type = function (obj) &#123; if (obj == null) &#123; // 当等于undefined 或者 null 直接返回 return obj + ""; &#125; return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj; &#125; 至此便可以检测JavaScript中的所有数据类型了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读高程有感之JavaScript代码可维护性]]></title>
    <url>%2F2016%2F03%2F18%2F%E8%AF%BB%E9%AB%98%E7%A8%8B%E6%9C%89%E6%84%9F%E4%B9%8BJavaScript%E4%BB%A3%E7%A0%81%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%2F</url>
    <content type="text"><![CDATA[近期一直在研读高级程序设计一书，其中第二十四章《最佳实践》中提到代码的可维护性，其中本人深有感触。 可维护性在从事IT编程工作一段时间后发现，每进一家新公司，都要花大量的时间去研读别人的代码，其余剩下的大量时间都是维护别人的代码，由于编程人员水平的参差不齐，所有经常在看上一个同事代码的时候也很难抑制内心的冲动，这写的什么鬼，一句注释没有，重复的代码这么多也不封装，所以编写可维护性的代码尤为重要，并且我觉得一个程序员一开始就应该先养成良好的代码习惯，做到像写诗一样写代码，从而能力才能更进一步，在我认为，代码风格都不好，其他一切都是空谈。 什么是可维护的代码可维护的代码有一些特征。一般来说，如果说代码是可维护的，它需要遵循以下特点。1、可理解性——其他人可以接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释。2、直观性——代码中的东西一看就能明白，不管其操作过程多么复杂。3、可适应性——代码以一种数据上的变化不要求完全重写的方法撰写。4、可扩展性——在代码架构上已考虑到在未来允许对核心功能进行扩展。5、可调试性——当有地方出错时，代码可以给予你足够的信息来尽可能直接地确定问题所在。对于专业人士而言，能写出可维护的 JavaScript 代码是非常重要的技能。 代码的约定绝大多数语言都有各自的代码约定，只要在网上一搜就能找到大量相关文档。由于 JavaScript 的可适应性，代码约定对它也很重要。这里建议大家有空经常到github上看一下别人的开源代码，会有意想不到的收获及思路。 1. 可读性可读性与代码作为文本文件的格式化方式有关。当所有人都使用一样的缩进方式时，整个项目中的代码都会更加易于阅读。目前许多框架都提供了这么一个检测代码的插件，eslint也是一个不错的练习，如vue-cli在构建项目时也会问你是否开启eslint，个人觉得是个不错的养成代码良好风格的练习方式 2. 多写注释很多时候我上个星期写的代码，这个星期就不记得了，所有多写注释十分重要 3. 变量名和函数名 变量名应为名词 如 car 或 person 函数名应该以动词开始，如 getName() 返回布尔类型值的函数一般以 is 开头，如 isEnable() 。 变量和函数都应使用合乎逻辑的名字，不用担心长度。因为最终在生产环境下代码可以被压缩打包，例如webpack和gulp都提供了这些功能。 4. 变量类型透明由于在 JavaScript 中变量是松散类型的，很容易就忘记变量所应包含的数据类型。合适的命名方式可以一定程度上缓解这个问题，但放到所有的情况下看，还不够。有三种表示变量数据类型的方式。//第一种方式：通过初始化指定变量类型1234var found = false; //布尔型var count = -1; //数字var name = ""; //字符串var person = null; //对象 初始化为一个特定的数据类型可以很好的指明变量的类型。但缺点是它无法用于函数声明中的函数参数。//第二种方法：用指定数据类型的匈牙利标记法，这个标记法在脚本语言中很流行，曾经很长时间也是 JavaScript 所推崇的方式，”o” 代表对象， “s” 代表字符串， “i”代表整数， “f” 代表浮点数， “b” 代表布尔型1234var bFound; //布尔型var iCount; //整数var sName; //字符串var oPerson; //对象 JavaScript 中用匈牙利标记法的好处是函数参数一样可以使用。但它的缺点是让代码某种程度上难以阅读，阻碍了没有用它时代码的直观性和句子式的特质。因此，匈牙利标记法失去了一些开发者的宠爱。//第三种方法：用于指定类型的类型注释 类型注释放在变量名右边，但是在初始化前面。1234var found /*:Boolean*/ = false;var count /*:int*/ = 10;var name /*:String*/ = "Nicholas";var person /*:Object*/ = null; 类型注释维持了代码的整体可读性，同时注入了类型信息。类型注释的缺点是你不能用多行注释一次注释大块的代码，因为类型注释也是多行注释，两者会冲突 。这三种常见指定变量数据类型的方法。每种都有各自的优势和劣势，要自己在使用之前进行评估。最重要的是要确定哪种最适合你的项目并一致使用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>