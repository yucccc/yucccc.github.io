<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[vue2绑定内联样式background的一些坑]]></title>
      <url>%2F2017%2F04%2F11%2Fvue2%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8Fbackground%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
      <content type="text"><![CDATA[此时我有一个需求，给一个盒子添加一个背景图片，这个背景图片是动态请求回来的，那么应该怎么做？看似简单，其实很考研对JavaScript基础的功底以及对vue生命周期的理解。正常情况下的vue内联样式如下写法： 12345&lt;div :style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;data: &#123; activeColor: 'red', fontSize: 30&#125; 此时的style绑定的是一个JavaScript对象，在JavaScript中不允许出现 “-“ ，那么绑定一个背景图片应该这么写：1234&lt;div :style="&#123;background: 'url('+ img +')'，backgroundSize:cover &#125;"&gt;&lt;/div&gt;data:&#123; img:'xxx.png'&#125; 好了背景图片已经成功通过字符串拼接的方式加上了，我们改为动态请求回来的。12345678910111213141516&lt;div :style="&#123;background: 'url('+ img +')'，backgroundSize:cover &#125;"&gt;&lt;/div&gt;data:&#123; img:'xxx.png'&#125;,methods:&#123;// 伪代码 请求数据 getImg()&#123; this.$http.get().then(function (e) &#123; this.img = e.data //将数据赋值给img &#125;.bind(this)) &#125;&#125;，created()&#123;// 调用函数 this.getImg()&#125; created vue2生命周期钩子函数在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定data，计算属性computed，方法methods，watcher/事件回调。此时你会发现虽然渲染了出来，但是报错了12Error in render functionCannot read property &apos;img&apos; of undefined 因为在生命周期 mounted 之前都是虚拟dom 也就是说 当页面已经渲染完，但是vue还没执行，所有数据丢失，此时我们加上1&lt;div v-if='img ' :style="&#123;background: 'url('+ img +')'，backgroundSize:cover &#125;"&gt;&lt;/div&gt; 表示有img属性的时候我们选择这个元素,至此就成功绑定背景图片了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb Windows环境安装及配置]]></title>
      <url>%2F2017%2F04%2F10%2Fmongodb%20Windows%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[因为最近要用 mongodb+node.js+vue2做一个小demo,所以第一步应该是先安装好mongodb,本以为是十分简单的安装,却踩了不少坑。 下载先到官网下载mongodb 点击到官网 选择合适自己的版本,我用的是window 所以下的window版本,此时的mongodb版本为3.4 安装一直点下一步,直到这里，我选择的是custom自定义安装.在E盘根目录下创建了一个MongoDB文件夹,安装在E盘的根目录下 E:\MongoDB文件夹中,要安装在哪里随你便,但是建议放在根目录下，并且记得你安装在哪，等会有用。此时你会看到如下文件创建数据库目录E:\MongoDB\data，接下来打开命令行窗口，切换到E:\MongoDB\bin 目录执行如下命令： mongod --dbpath E:\MongoDB\data–dbpath 指定数据库路径 创建的data是用来存放数据的此时如果最后一行出现（视情况而定,最后是 on port 27017 ）即为成功2017-04-10T21:14:16.257+0800 I NETWORK [thread1] waiting for connections on port 27017在浏览中输入：http://localhost:27017如果出现 It looks like you are trying to access MongoDB over HTTP on the native driver port. 代表成功安装了。但是你会发现，这样十分的麻烦，每次需要指定数据库，并且需要跑到目录下开启数据库，接下来就是将MongoDB安装为Windows服务 配置window服务1:在E:\mongodb\data下新建文件夹log（存放日志文件）并且在里面新建文件mongodb.log2:在E:\mongodb中新建文件mongo.config,用记事本打开并在mongo.config中输入12dbpath=E:\mongodb\data logpath=E:\mongodb\log\mongo.log dppath 代表数据库存放路径logpath 代表日志存放路径如图 重点来了**以管理员身份运行cmd命令行,记得一定要用管理员身份运行,不然会出问题，右击以管理员身份运行,进入E:\mongodb\bin目录，如果你此时在c盘下可以输入命令：1cd E:\MongoDB\bin 你会发现并没切换到E盘 再次输入1E: 就可以切换到 E:\MongoDB\bin 目录下输入如下的命令：1mongod --config E:\mongodb\mongo.config --install --serviceName &quot;MongoDB&quot; 如果输出了日期，代表成功了，没输入可以重复上面命令，或者你没用管理员身份运行 打开cmd输入services.msc查看服务找到MongoDB服务，点击启动即可，至此你就成功安装了mongodb并且开机自动启动]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VueX在ie,safari浏览器无法解析的解决方法]]></title>
      <url>%2F2017%2F04%2F08%2FVueX%E5%9C%A8ie-safari%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[今天在做一个vue2项目时,引入了vuex做一些状态管理，结果调试发现在ie11以下页面显示不出来，打开控制台发现出现如下错误： 1[vuex] vuex requires a Promise polyfill in this browser. 意思为vuex需要在这个浏览器上解析不了 因为vuex基于promise, IE浏览器没有内置Promise对象那么此时我们需要一个解析promise ES6语法的东西。不仅如此，几乎所有的ES6新增的方法在IE都不能用，比如Array.from。因为babel只会转译语法，并不会新增方法。此时你需要babel Polyfill polyfillpolyfill是一种js库，为低版本的js环境补足高版本js里定义的一些原生功能 用法十分简单如下：1：下载1npm install --save babel-polyfill 2 :方法一 ：在main.js最顶部加入1import 'babel-polyfill';//解决ie浏览器不支持promise 方法二：或者在webpack中加入12345678module.exports = &#123; // entry: &#123; // 这是原本脚手架配置的 // app: './src/main.js' // &#125;, entry: &#123; // 替换成 app: ['babel-polyfill','./src/main.js'] &#125;,&#125; 这种需要重新npm run dev 因为更改了webpack的配置两种加入方法都可以解决，个人建议第一种方便快捷，此时重新打开浏览器项目就能正常解析了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue2中注册在router-link上事件无效解决方法]]></title>
      <url>%2F2017%2F04%2F06%2FVue2%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%9C%A8router-link%E4%B8%8A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[今天用vue在做一个tab栏切换的时候，偶然发现我绑定在router-link上的click并不会触发，后来测试发现，所有绑定在router-link中的事件都不会促发此后查看了官方的文档，也并没有给出明确的说明：代码如下： 1&lt;router-link @click="change"&gt;&lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; 此刻我发现，无论如何定义在methods 中的 change函数并不会触发，这是为什么呢？在github查看了vue-router的代码后发现： 事件被阻止如果当前router-link的tag不是a的话（官方文档中说明：默认为a，可以通过tag改变渲染后的标签），那么就会往自己的子元素（组件）找，找到的第一个就会把一些属性及时间覆盖过去。所以此时事件是被阻止了。个人看法：因为router-link的作用是单纯的路由跳转，如果不阻止事件的话，也许会有很多坑，所以作者干脆阻止了其他事件的触发 如何解决1&lt;router-link @click.native="change"&gt;&lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; 只需要在@click后面加上native就可以了 原生事件添加native事件修饰符之后变为原生事件1$element.addEventListener(click, callback); 此时a标签并不会阻止，至此便可以解决绑定在router-link身上的事件不会触发的问题。其次，想要实现tab切换添加class可以在router中添加如下配置：1234export default new Router(&#123; routes: [],// 路由跳转配置 linkActiveClass:'active' // 在路由中添加配置 active 为跳转到该路由时添加的激活类名&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2搭建开发环境并且可以请求本地数据设置]]></title>
      <url>%2F2017%2F04%2F04%2Fvue2%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[这一个问题困扰了我许久，怎么用vue搭建开发环境并且可以请求本地数据，因为webpack-dev-server在编译vue的时候会默认开启一个端口，本地的服务器肯定也会拥有一个端口，那么不同端口的请求又为跨域请求，此时又不能把端口改为相同，因为这样会造成端口冲突，当然不考虑跨域jsonp之类，虽然jsonp可以做，但是在开发中无疑增加了繁杂度，并且这样做的话上线又要改请求方式，十分麻烦，那么应该怎么做呢？这时候就要用到webpack里面的开启代理的配置,即把请求的地址转发到指定的地址，并且允许跨域请求 如下： 开启webpack代理此时找到config文件中的index.js,拉到底部找到dev：{ 里面是一些端口的配置} 在里面添加上如下配置 1234567891011121314151617 dev: &#123; env: require('./dev.env'), port: 9999, autoOpenBrowser: true, assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: &#123;// 这里用的是vue-cli脚手架,默认proxyTable:&#123;&#125; ,内容为空 只需要配置这个参数即可 '/webapi': &#123;//代表你以什么为开始请求数据 表示以webapi开头的请求就开启代理 target: 'http://im.ivymei.com', //代表代理地址 即：如果 this.$http.get('/webapi').then() 此时会变成http://www.baidu.com/webapi changeOrigin: true,// 表示允许跨域 pathRewrite: &#123; '^/webapi': '/webapi' //可要可不要 &#125; &#125; &#125;, cssSourceMap: false,&#125; 至此就可以愉快的请求本地数据了 8080端口也能请求80端口的数据了 最终打包上线也不需要改任何代码,更多的webpack代理设置请查阅webpack官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读高程有感之JavaScript代码可维护性]]></title>
      <url>%2F2016%2F03%2F18%2F%E8%AF%BB%E9%AB%98%E7%A8%8B%E6%9C%89%E6%84%9F%E4%B9%8BJavaScript%E4%BB%A3%E7%A0%81%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%2F</url>
      <content type="text"><![CDATA[近期一直在研读高级程序设计一书，其中第二十四章《最佳实践》中提到代码的可维护性，其中本人深有感触。 可维护性在从事IT编程工作一段时间后发现，每进一家新公司，都要花大量的时间去研读别人的代码，其余剩下的大量时间都是维护别人的代码，由于编程人员水平的参差不齐，所有经常在看上一个同事代码的时候也很难抑制内心的冲动，这写的什么鬼，一句注释没有，重复的代码这么多也不封装，所以编写可维护性的代码尤为重要，并且我觉得一个程序员一开始就应该先养成良好的代码习惯，做到像写诗一样写代码，从而能力才能更进一步，在我认为，代码风格都不好，其他一切都是空谈。 什么是可维护的代码可维护的代码有一些特征。一般来说，如果说代码是可维护的，它需要遵循以下特点。1、可理解性——其他人可以接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释。2、直观性——代码中的东西一看就能明白，不管其操作过程多么复杂。3、可适应性——代码以一种数据上的变化不要求完全重写的方法撰写。4、可扩展性——在代码架构上已考虑到在未来允许对核心功能进行扩展。5、可调试性——当有地方出错时，代码可以给予你足够的信息来尽可能直接地确定问题所在。对于专业人士而言，能写出可维护的 JavaScript 代码是非常重要的技能。 代码的约定绝大多数语言都有各自的代码约定，只要在网上一搜就能找到大量相关文档。由于 JavaScript 的可适应性，代码约定对它也很重要。这里建议大家有空经常到github上看一下别人的开源代码，会有意想不到的收获及思路。 1. 可读性可读性与代码作为文本文件的格式化方式有关。当所有人都使用一样的缩进方式时，整个项目中的代码都会更加易于阅读。目前许多框架都提供了这么一个检测代码的插件，eslint也是一个不错的练习，如vue-cli在构建项目时也会问你是否开启eslint，个人觉得是个不错的养成代码良好风格的练习方式 2. 多写注释很多时候我上个星期写的代码，这个星期就不记得了，所有多写注释十分重要 3. 变量名和函数名 变量名应为名词 如 car 或 person 函数名应该以动词开始，如 getName() 返回布尔类型值的函数一般以 is 开头，如 isEnable() 。 变量和函数都应使用合乎逻辑的名字，不用担心长度。因为最终在生产环境下代码可以被压缩打包，例如webpack和gulp都提供了这些功能。 4. 变量类型透明由于在 JavaScript 中变量是松散类型的，很容易就忘记变量所应包含的数据类型。合适的命名方式可以一定程度上缓解这个问题，但放到所有的情况下看，还不够。有三种表示变量数据类型的方式。//第一种方式：通过初始化指定变量类型1234var found = false; //布尔型var count = -1; //数字var name = ""; //字符串var person = null; //对象 初始化为一个特定的数据类型可以很好的指明变量的类型。但缺点是它无法用于函数声明中的函数参数。//第二种方法：用指定数据类型的匈牙利标记法，这个标记法在脚本语言中很流行，曾经很长时间也是 JavaScript 所推崇的方式，”o” 代表对象， “s” 代表字符串， “i”代表整数， “f” 代表浮点数， “b” 代表布尔型1234var bFound; //布尔型var iCount; //整数var sName; //字符串var oPerson; //对象 JavaScript 中用匈牙利标记法的好处是函数参数一样可以使用。但它的缺点是让代码某种程度上难以阅读，阻碍了没有用它时代码的直观性和句子式的特质。因此，匈牙利标记法失去了一些开发者的宠爱。//第三种方法：用于指定类型的类型注释 类型注释放在变量名右边，但是在初始化前面。1234var found /*:Boolean*/ = false;var count /*:int*/ = 10;var name /*:String*/ = "Nicholas";var person /*:Object*/ = null; 类型注释维持了代码的整体可读性，同时注入了类型信息。类型注释的缺点是你不能用多行注释一次注释大块的代码，因为类型注释也是多行注释，两者会冲突 。这三种常见指定变量数据类型的方法。每种都有各自的优势和劣势，要自己在使用之前进行评估。最重要的是要确定哪种最适合你的项目并一致使用。]]></content>
    </entry>

    
  
  
</search>
