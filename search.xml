<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[VueX在ie,safari浏览器无法解析的解决方法]]></title>
      <url>%2F2017%2F04%2F08%2FVueX%E5%9C%A8ie-safari%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[今天在做一个vue2项目时,引入了vuex做一些状态管理，结果调试发现在ie11以下页面显示不出来，打开控制台发现出现如下错误： 1[vuex] vuex requires a Promise polyfill in this browser. 意思为vuex需要在这个浏览器上解析不了 因为vuex基于promise, IE浏览器没有内置Promise对象那么此时我们需要一个解析promise ES6语法的东西。不仅如此，几乎所有的ES6新增的方法在IE都不能用，比如Array.from。因为babel只会转译语法，并不会新增方法。此时你需要babel Polyfill polyfillpolyfill是一种js库，为低版本的js环境补足高版本js里定义的一些原生功能 用法十分简单如下：1：下载1npm install --save babel-polyfill 2 :方法一 ：在main.js最顶部加入1import 'babel-polyfill';//解决ie浏览器不支持promise 方法二：或者在webpack中加入12345678module.exports = &#123; // entry: &#123; // 这是原本脚手架配置的 // app: './src/main.js' // &#125;, entry: &#123; // 替换成 app: ['babel-polyfill','./src/main.js'] &#125;,&#125; 这种需要重新npm run dev 因为更改了webpack的配置两种加入方法都可以解决，个人建议第一种方便快捷，此时重新打开浏览器项目就能正常解析了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue2中注册在router-link上事件无效解决方法]]></title>
      <url>%2F2017%2F04%2F06%2FVue2%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%9C%A8router-link%E4%B8%8A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[今天用vue在做一个tab栏切换的时候，偶然发现我绑定在router-link上的click并不会触发，后来测试发现，所有绑定在router-link中的事件都不会促发此后查看了官方的文档，也并没有给出明确的说明：代码如下： 1&lt;router-link @click="change"&gt;&lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; 此刻我发现，无论如何定义在methods 中的 change函数并不会触发，这是为什么呢？在github查看了vue-router的代码后发现： 事件被阻止如果当前router-link的tag不是a的话（官方文档中说明：默认为a，可以通过tag改变渲染后的标签），那么就会往自己的子元素（组件）找，找到的第一个就会把一些属性及时间覆盖过去。所以此时事件是被阻止了。个人看法：因为router-link的作用是单纯的路由跳转，如果不阻止事件的话，也许会有很多坑，所以作者干脆阻止了其他事件的触发 如何解决1&lt;router-link @click.native="change"&gt;&lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; 只需要在@click后面加上native就可以了 原生事件添加native事件修饰符之后变为原生事件1$element.addEventListener(click, callback); 此时a标签并不会阻止，至此便可以解决绑定在router-link身上的事件不会触发的问题。其次，想要实现tab切换添加class可以在router中添加如下配置：1234export default new Router(&#123; routes: [],// 路由跳转配置 linkActiveClass:'active' // 在路由中添加配置 active 为跳转到该路由时添加的激活类名&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2搭建开发环境并且可以请求本地数据设置]]></title>
      <url>%2F2017%2F04%2F04%2Fvue2%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E8%AF%B7%E6%B1%82%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[这一个问题困扰了我许久，怎么用vue搭建开发环境并且可以请求本地数据，因为webpack-dev-server在编译vue的时候会默认开启一个端口，本地的服务器肯定也会拥有一个端口，那么不同端口的请求又为跨域请求，此时又不能把端口改为相同，因为这样会造成端口冲突，当然不考虑跨域jsonp之类，虽然jsonp可以做，但是在开发中无疑增加了繁杂度，并且这样做的话上线又要改请求方式，十分麻烦，那么应该怎么做呢？这时候就要用到webpack里面的开启代理的配置,即把请求的地址转发到指定的地址，并且允许跨域请求 如下： 开启webpack代理此时找到config文件中的index.js,拉到底部找到dev：{ 里面是一些端口的配置} 在里面添加上如下配置 1234567891011121314151617 dev: &#123; env: require('./dev.env'), port: 9999, autoOpenBrowser: true, assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: &#123;// 这里用的是vue-cli脚手架,默认proxyTable:&#123;&#125; ,内容为空 只需要配置这个参数即可 '/webapi': &#123;//代表你以什么为开始请求数据 表示以webapi开头的请求就开启代理 target: 'http://im.ivymei.com', //代表代理地址 即：如果 this.$http.get('/webapi').then() 此时会变成http://www.baidu.com/webapi changeOrigin: true,// 表示允许跨域 pathRewrite: &#123; '^/webapi': '/webapi' //可要可不要 &#125; &#125; &#125;, cssSourceMap: false,&#125; 至此就可以愉快的请求本地数据了 8080端口也能请求80端口的数据了 最终打包上线也不需要改任何代码,更多的webpack代理设置请查阅webpack官方文档]]></content>
    </entry>

    
  
  
</search>
